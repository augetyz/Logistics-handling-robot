/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * File Name          : freertos.c
 * Description        : Code for freertos applications
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under Ultimate Liberty license
 * SLA0044, the "License"; You may not use this file except in compliance with
 * the License. You may obtain a copy of the License at:
 *                             www.st.com/SLA0044
 *
 ******************************************************************************
 */
 /* USER CODE END Header */

 /* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "soft_user.h"
#include "string.h"
#include "JY61.h"
#include "servo.h"
#include "dma.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#include "motor_ctrl.h"
#include "pid.h"
#include "HI229.h"
#include "fashion_star_uart_servo.h"
#include "math.h"
// #include "HI229.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define Led_Toggle GPIOC->ODR ^= GPIO_PIN_13 // LED_Toggle函数宏定义
#define IMU_speed 45                         // IMU数据采集处理频率控制参数
#define Wit_IMU
#define HWT101
#define turn_angle 0f

#define UNUSED_VARIABLE(X) ((void)(X))
#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
#define symbol(y) (y >= 0 ? 1 : -1)


#define IMU_excursion   0.0f //-1.15f // 十字激光初始化陀螺仪后，对陀螺仪数据的偏移值


#define color_circle_x_RM -7   
#define color_circle_y_RM -35
//四级复习： 粗加工  rough machining

#define color_circle_x_TX -7   
#define color_circle_y_TX -15

#define color_Stacking_x -65 
#define color_Stacking_y 60
//四级复习：暂存 temporary storage
#define color_location_speed 40

#define red_circle      1
#define green_circle    2
#define blue_circle     3



//里程计
#define Start_Left              -200

#define Start_CR_Go               750, 88

#define RMA_Rough_go            460
#define RMA_Rough_left          -920

#define Rough_TS_left           -675
#define Rough_TS_Back           -785

#define TS_RMA_go               800

#define TS_RMA_right            1555
#define TS_RMA_Back             -450
#define RMA_Rough_go_2          450
#define RMA_Rough_left_2        -930
#define Rough_TS_left_2         -680
#define Rough_TS_Back_2         -835
#define TS_Start_back           -1710
#define TS_Start_left           -1055

//色环逆解调整
#define Red_Put_H               -65     //红色色环放置高度
#define Red_Get_W               -285    //红色色环回收距离(最小为Ychange-10)
#define Green_Put_H             -42     //绿色色环放置高度
#define Blue_Put_H              -65     //蓝色色环放置高度
#define Blue_Get_W              -282    //蓝色色环回收距离

#define Red_Rotary_table        100
#define Green_Rotary_table      -27
#define Blue_Rotary_table       -140

#define Color_circle_location Camera_color_circle_Green
#define Stack_circle_location Camera_color_Stacking_Green
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

extern char s_cDataUpdate, s_cCmd; // MPU6050移植参数，不用管

extern servo_status servo_motion[];

extern Usart_DataTypeDef usart4;

uint8_t OS_status = 0; // 任务初始化标志位，为1则初始化OK，为0则还没有嘞

uint8_t debug_date[600] = { 0 }; // debug数据缓存区，用于缓存需要用来上传的debug数据。

uint8_t IMU_date[IMU_speed] = { 0 }; // MPU6050数据缓冲区、采用DMA+串口方式接收

uint8_t usart_3_date[25] = { 0 };
uint8_t usart_6_date[22] = { 0 };

uint8_t servo_sign; // 1表示上次动作组已经执行完毕， 0表示上次动作组正在执行

uint16_t modetime = 100;

Usart_DataTypeDef* servoUsart = &usart4;

raw_t raw = { 0 };     /* IMU stram read/control struct */
uint8_t decode_succ; /* 0: no new frame arrived, 1: new frame arrived */
uint8_t Task_verify = Start;

uint32_t time_test[2] = { 0 };

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */
SemaphoreHandle_t IMUdate_RX_Sem_Handle = NULL; // 信号量初始化，用于作为IMU数据接收完成后的回响，开启IMU_TASK函数的执行。

SemaphoreHandle_t usart3_RX_Sem_Handle = NULL;

SemaphoreHandle_t usart6_RX_Sem_Handle = NULL;

SemaphoreHandle_t Servo_Sem_Handle = NULL;

SemaphoreHandle_t Distance_Sem_Handle = NULL;

SemaphoreHandle_t key_debug_Sem_Handle = NULL;

SemaphoreHandle_t key_start_Sem_Handle = NULL;

SemaphoreHandle_t key_stop_Sem_Handle = NULL;

QueueHandle_t Speed_Queue = NULL;
QueueHandle_t goal_Queue = NULL;
QueueHandle_t IMU_Queue = NULL;
QueueHandle_t debug_Queue = NULL;
QueueHandle_t angle_Queue = NULL;
QueueHandle_t servo_Queue = NULL;
QueueHandle_t distance_Queue = NULL;
QueueHandle_t color_Queue = NULL;
QueueHandle_t IDR_date_Queue = NULL;
/* USER CODE END Variables */
osThreadId defaultTaskHandle;
osThreadId myTask_keyHandle;
osThreadId myTask_ledHandle;
osThreadId myTask_IMUHandle;
osThreadId myTask_debugHandle;
osThreadId myTask_usbHandle;
osThreadId myTask_usartHandle;
osThreadId myTask_oledHandle;
osThreadId myTask_servoHandle;
osThreadId myTask_speedHandle;
osThreadId myTask_pidHandle;
osThreadId myTask_doingHandle;

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void StartDefaultTask(void const* argument);
void key_Task(void const* argument);       // 一键启动与一键调试
void led_Task(void const* argument);       // LED闪烁
void IMU_Task(void const* argument);       // 获取IMU数据
void deubg_Task(void const* argument);     // 一键调试模式
void usb_Task(void const* argument);        // 未实现
void usart_Task(void const* argument);     // 获取激光数据与树莓派数据
void oled_Task(void const* argument);      // 未实现
void servo_Task(void const* argument);     // 控制机械臂动作组
void speed_Task(void const* argument);     // 获取四个轮子编码器的值，并统计行走距离
void pid_Task(void const* argument);       // 负责每个轮子的闭环控制
void doing_Task(void const* argument);     // 主控任务

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* GetIdleTaskMemory prototype (linked to static allocation support) */
void vApplicationGetIdleTaskMemory(StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, uint32_t* pulIdleTaskStackSize);

/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory(StaticTask_t** ppxIdleTaskTCBBuffer, StackType_t** ppxIdleTaskStackBuffer, uint32_t* pulIdleTaskStackSize)
{
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
    *ppxIdleTaskStackBuffer = &xIdleStack[0];
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
    /* place for user code */
}
/* USER CODE END GET_IDLE_TASK_MEMORY */

/**
 * @brief  FreeRTOS initialization
 * @param  None
 * @retval None
 */
void MX_FREERTOS_Init(void)
{
    /* USER CODE BEGIN Init */

    /* USER CODE END Init */

    /* USER CODE BEGIN RTOS_MUTEX */
    /* add mutexes, ... */
    /* USER CODE END RTOS_MUTEX */

    /* USER CODE BEGIN RTOS_SEMAPHORES */
    /* add semaphores, ... */
    // IMUdate_RX_Sem_Handle二值信号量创建
    IMUdate_RX_Sem_Handle = xSemaphoreCreateBinary();

    usart3_RX_Sem_Handle = xSemaphoreCreateBinary();

    usart6_RX_Sem_Handle = xSemaphoreCreateBinary();

    Servo_Sem_Handle = xSemaphoreCreateBinary();

    Distance_Sem_Handle = xSemaphoreCreateBinary();

    key_debug_Sem_Handle = xSemaphoreCreateBinary();

    key_start_Sem_Handle = xSemaphoreCreateBinary();

    key_stop_Sem_Handle = xSemaphoreCreateBinary();
    /* USER CODE END RTOS_SEMAPHORES */

    /* USER CODE BEGIN RTOS_TIMERS */
    /* start timers, add new ones, ... */
    /* USER CODE END RTOS_TIMERS */

    /* USER CODE BEGIN RTOS_QUEUES */
    /* add queues, ... */
    Speed_Queue = xQueueCreate((UBaseType_t)1, /* 消息队列的长度 */ // 实时速度参数传递消息队列
        (UBaseType_t)sizeof(biu));           /* 消息的大小 */
    goal_Queue = xQueueCreate((UBaseType_t)2, /* 消息队列的长度 */  // 目标速度传递消息队列
        (UBaseType_t)sizeof(biu));            /* 消息的大小 */
    IMU_Queue = xQueueCreate((UBaseType_t)1,                        /* 消息队列的长度 */
        (UBaseType_t)sizeof(imu));             /* 消息的大小 */
    debug_Queue = xQueueCreate((UBaseType_t)1,                      /* 消息队列的长度 */
        (UBaseType_t)sizeof(biu));           /* 消息的大小 */
    angle_Queue = xQueueCreate((UBaseType_t)1,                      /* 消息队列的长度 */
        (UBaseType_t)sizeof(imu));           /* 消息的大小 */
    servo_Queue = xQueueCreate((UBaseType_t)1,                      /* 消息队列的长度 */
        (UBaseType_t)sizeof(servo_status));  /* 消息的大小 */
    distance_Queue = xQueueCreate((UBaseType_t)1,                   /* 消息队列的长度 */
        (UBaseType_t)sizeof(biu));        /* 消息的大小 */
    color_Queue = xQueueCreate((UBaseType_t)1,                      /* 消息队列的长度 */
        (UBaseType_t)sizeof(biu_int_16));    /* 消息的大小 */
    IDR_date_Queue = xQueueCreate((UBaseType_t)1,                   /* 消息队列的长度 */
        (UBaseType_t)sizeof(IDR_date));   /* 消息的大小 */
    /* USER CODE END RTOS_QUEUES */

    /* Create the thread(s) */
    /* definition and creation of defaultTask */
    osThreadDef(defaultTask, StartDefaultTask, osPriorityAboveNormal, 0, 128);
    defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

    /* definition and creation of myTask_key */
    osThreadDef(myTask_key, key_Task, osPriorityAboveNormal, 0, 128);
    myTask_keyHandle = osThreadCreate(osThread(myTask_key), NULL);

    /* definition and creation of myTask_led */
    osThreadDef(myTask_led, led_Task, osPriorityIdle, 0, 128);
    myTask_ledHandle = osThreadCreate(osThread(myTask_led), NULL);

    /* definition and creation of myTask_IMU */
    osThreadDef(myTask_IMU, IMU_Task, osPriorityNormal, 0, 256);
    myTask_IMUHandle = osThreadCreate(osThread(myTask_IMU), NULL);

    /* definition and creation of myTask_debug */
    osThreadDef(myTask_debug, deubg_Task, osPriorityLow, 0, 256);
    myTask_debugHandle = osThreadCreate(osThread(myTask_debug), NULL);

    /* definition and creation of debug_get */
//    osThreadDef(myTask_usb, usb_Task, osPriorityAboveNormal, 0, 128);
//    myTask_usbHandle = osThreadCreate(osThread(myTask_usb), NULL);

    /* definition and creation of myTask_usart */
    osThreadDef(myTask_usart, usart_Task, osPriorityNormal, 0, 128);
    myTask_usartHandle = osThreadCreate(osThread(myTask_usart), NULL);

    /* definition and creation of myTask_oled */
    osThreadDef(myTask_oled, oled_Task, osPriorityLow, 0, 128);
    myTask_oledHandle = osThreadCreate(osThread(myTask_oled), NULL);

    /* definition and creation of myTask_servo */
    osThreadDef(myTask_servo, servo_Task, osPriorityHigh, 0, 128);
    myTask_servoHandle = osThreadCreate(osThread(myTask_servo), NULL);

    /* definition and creation of myTask_speed */
    osThreadDef(myTask_speed, speed_Task, osPriorityRealtime, 0, 128);
    myTask_speedHandle = osThreadCreate(osThread(myTask_speed), NULL);

    /* definition and creation of myTask_pid */
    osThreadDef(myTask_pid, pid_Task, osPriorityRealtime, 0, 512);
    myTask_pidHandle = osThreadCreate(osThread(myTask_pid), NULL);

    /* definition and creation of myTask_doing */
    osThreadDef(myTask_doing, doing_Task, osPriorityRealtime, 0, 512);
    myTask_doingHandle = osThreadCreate(osThread(myTask_doing), NULL);

    /* USER CODE BEGIN RTOS_THREADS */
    /* add threads, ... */

    /* USER CODE END RTOS_THREADS */
}

/* USER CODE BEGIN Header_StartDefaultTask */
/**
 * @brief  优先级最低的任务，点个灯在里面，可以通过观察led闪烁情况观察任务运行情况，
 *          如果不稳定，则任务优先级、缓存分配存在问题
 * @param  argument: Not used
 * @retval None
 */
 /* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const* argument)
{
    /* USER CODE BEGIN StartDefaultTask */
    /* Infinite loop */
    for (;;)
    {
        Led_Toggle;
        osDelay(100);
    }
    /* USER CODE END StartDefaultTask */
}

/* USER CODE BEGIN Header_key_Task */
/**
 * @brief 按键任务，用于检测按键触发，没有使用中断方式（不稳定而且占用资源），这里使用轮询方式依然很nice
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_key_Task */
void key_Task(void const* argument)
{
    /* USER CODE BEGIN key_Task */
    /* Infinite loop */

    for (;;)
    {

        if ((GPIOA->IDR & (1 << 15)) == 0)
        {
            osDelay(10);
            if ((GPIOA->IDR & (1 << 15)) == 0)
            {
                while ((GPIOA->IDR & (1 << 15)) == 0)
                {
                    osDelay(1);
                }
                /*do something*/
                xSemaphoreGive(key_start_Sem_Handle);
            }
        }
        if ((GPIOC->IDR & (1 << 0)) == 0)
        {
            osDelay(10);
            if ((GPIOC->IDR & (1 << 0)) == 0)
            {
                while ((GPIOC->IDR & (1 << 0)) == 0)
                {
                    osDelay(1);
                }

                /*do something*/
                xSemaphoreGive(key_start_Sem_Handle);
            }
        }
        if ((GPIOC->IDR & (1 << 1)) == 0)
        {
            osDelay(10);
            if ((GPIOC->IDR & (1 << 1)) == 0)
            {
                while ((GPIOC->IDR & (1 << 1)) == 0)
                {
                    osDelay(1);
                }
                /*do something*/
                xSemaphoreGive(key_stop_Sem_Handle);
            }
        }
        if ((GPIOC->IDR & (1 << 2)) == 0)
        {
            osDelay(10);
            if ((GPIOC->IDR & (1 << 2)) == 0)
            {
                while ((GPIOC->IDR & (1 << 2)) == 0)
                {
                    osDelay(1);
                }
                /*do something*/
                xSemaphoreGive(key_debug_Sem_Handle);

            }
        }
        osDelay(1);
    }
    /* USER CODE END key_Task */
}

/* USER CODE BEGIN Header_led_Task */
/**
 * @brief RGB led任务，用于显示当前状态
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_led_Task */
void led_Task(void const* argument)
{
    /* USER CODE BEGIN led_Task */
    /* Infinite loop */
    GPIOC->ODR |= GPIO_PIN_3;
    for (;;)
    {
        GPIOC->ODR ^= GPIO_PIN_4;
        osDelay(50);
    }
    /* USER CODE END led_Task */
}

/* USER CODE BEGIN Header_IMU_Task */
/**
 * @brief IMU数据处理任务、优先级较高，但收到二值信息量控制，当二值信息量被释放后，此任务才可以执行，
 * 信息量释放速度受宏定义IMU_speed控制。
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_IMU_Task */
void IMU_Task(void const* argument)
{
    /* USER CODE BEGIN IMU_Task */
    /* Infinite loop */
#ifndef HWT101
    int i;
#endif
#ifdef HWT101
    uint8_t date_set_0[5] = { 0XFF,0XAA,0X76,0X00,0X00 }; // Z轴角度归零命令
    HAL_UART_Transmit(&huart2, date_set_0, 5, 100);//Z轴角度归零  
#endif
    imu imu_car;
    OS_status = 1;
    HAL_UART_Receive_DMA(&huart2, IMU_date, IMU_speed);
    for (;;)
    {
        // 获取二值信号量 xSemaphore,没获取到则一直等待
        xSemaphoreTake(IMUdate_RX_Sem_Handle, portMAX_DELAY); /* 等待时间 */
        taskENTER_CRITICAL();
#ifdef Wit_IMU
#ifdef JY61
        for (i = 0; i < IMU_speed; i++)
        {
            WitSerialDataIn(IMU_date[i]);
        }
        if (s_cDataUpdate)
        {
            for (i = 0; i < 3; i++)
            {
                imu_car.IMU[i] = sReg[Roll + i] / 32768.0f * 180.0f;
            }
            imu_car.IMU[2] += IMU_excursion;
            xQueueSend(IMU_Queue, &imu_car, 0);
            xQueueSend(angle_Queue, &imu_car, 0);
        }
#endif 
#ifdef HWT101
        imu_car.IMU[2] = Wit_HWT101_date_deal(IMU_date);
        if (imu_car.IMU[2] != 400)
        {
            imu_car.IMU[2] += IMU_excursion;
            xQueueSend(IMU_Queue, &imu_car, 0);
            xQueueSend(angle_Queue, &imu_car, 0);
        }
#endif // DEBUG

#else
        for (i = 0; i < IMU_speed; i++)
        {
            decode_succ = ch_serial_input(&raw, IMU_date[i]);
            if (decode_succ == 1)
                break;
        }

        if (decode_succ)
        {
            for (i = 0; i < 3; i++)
            {
                imu_car.IMU[i] = raw.imu[0].eul[i];
            }
            imu_car.IMU[2] += IMU_excursion;
            xQueueSend(IMU_Queue, &imu_car, 0);
            xQueueSend(angle_Queue, &imu_car, 0);
        }
#endif

        HAL_UART_Receive_DMA(&huart2, IMU_date, IMU_speed);
        taskEXIT_CRITICAL();
    }
    /* USER CODE END IMU_Task */
}
/* USER CODE BEGIN Header_deubg_Task */
/**
 * @brief 小车状态上传任务，使用串口一DMA发送，运行周期1000ms
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_deubg_Task */
// #define Motor_debug
void deubg_Task(void const* argument)
{
    /* USER CODE BEGIN deubg_Task */
    /* Infinite loop */
#ifdef Motor_debug
    imu imu_car = { 0 };
    biu speed_now;
    biu speed_goal;
#endif // DEBUG
    float serve_angle[5] = { 0,0,0,0,0 };
    uint8_t i = 0;
    for (;;)
    {

        //        xQueueReceive(IMU_Queue, &imu_car, 3);
        //        xQueueReceive(debug_Queue, &speed_goal, 3);
        //        xQueuePeek(Speed_Queue, &speed_now, 3);
        for (i = 1;i < 5;i++)
        {
            FSUS_QueryServoAngle(servoUsart, i, &serve_angle[i - 1]);
            osDelay(10);
        }
        FSUS_QueryServoAngle(servoUsart, 6, &serve_angle[4]);

        //        sprintf((char*)debug_date, "%.2f,%.2f,%.2f,%d,%d,%d,%d,%d,%d,%d,%d\n",
        //            imu_car.IMU[0], imu_car.IMU[1], imu_car.IMU[2],
        //            speed_now.date[0], speed_goal.date[0], speed_now.date[1], speed_goal.date[1],
        //            speed_now.date[2], speed_goal.date[2], speed_now.date[3], speed_goal.date[3]);
        sprintf((char*)debug_date, "%3.1f,%3.1f,%3.1f,%3.1f,%3.1f\n", serve_angle[0], serve_angle[1], serve_angle[2], serve_angle[3], serve_angle[4]);
        HAL_UART_Transmit_DMA(&huart1, debug_date, strlen((char*)debug_date));

        osDelay(50);
    }
    /* USER CODE END deubg_Task */
}

/* USER CODE BEGIN Header_debug_get_Task */
/**
 * @brief Function implementing the debug_get thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_debug_get_Task */


/* USER CODE BEGIN Header_usart_Task */
/**
 * @brief Function implementing the myTask_usart thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_usart_Task */
void usart_Task(void const* argument)
{
    /* USER CODE BEGIN usart_Task */
    /* Infinite loop */

    taskENTER_CRITICAL();

    int i = 0, num, sign = 0;
    int16_t x = 0;
    int16_t y = 0;
    int16_t wide = 0;
    int16_t height = 0;

    char* f = (char*)&x;
    char* h = (char*)&y;
    char* u = (char*)&wide;
    char* q = (char*)&height;
    biu_int_16 color_date;
    HAL_UART_Receive_DMA(&huart3, usart_3_date, 22);
    HAL_UART_Receive_DMA(&huart6, usart_6_date, 14);

    taskEXIT_CRITICAL();

    for (;;)
    {
        // USART3
        if (xSemaphoreTake(usart3_RX_Sem_Handle, 10) == pdTRUE) /* 等待时间 */
        {
            vTaskSuspendAll();

            for (i = 0; i < 8; i++)
            {
                if (usart_3_date[i] == 0X2C && usart_3_date[i + 10] == 0X5B)
                {
                    num = i;
                    if (usart_3_date[num + 1] == 0X12)
                        sign = 1; // 当前获取到的数据是物块颜色
                    else if (usart_3_date[num + 1] == 0X21)
                        sign = 2; // 当前获取到的数据是二维码值
                    else if (usart_3_date[num + 1] == 0X3C)
                        sign = 3; // 当前获取到的数据是色环定位数据
                    else
                        sign = 0;
                    break;
                }
                sign = 0;
            }
            // HAL_UART_Transmit_DMA(&huart1, usart_3_date, 22);
            if (sign == 1) // 识别物块颜色
            {

                for (i = 0; i < 2; i++)
                {
                    *(f + i) = *(usart_3_date + num + i + 2);
                }
                //          i=*(f);*(f)=*(f+1);*(f+1)=i;

                for (i = 0; i < 2; i++)
                {
                    *(h + i) = *(usart_3_date + num + i + 4);
                }
                for (i = 0; i < 2; i++)
                {
                    *(u + i) = *(usart_3_date + num + i + 6);
                }
                for (i = 0; i < 2; i++)
                {
                    *(q + i) = *(usart_3_date + num + i + 8);
                }
                //          i=*(h);*(h)=*(h+1);*(h+1)=i;
                if ((x != 520 && y != 520) && (y != 9))
                {
                    color_date.date[0] = x;
                    color_date.date[1] = y;
                    color_date.date[2] = 11;
                    color_date.date[3] = height;
                    xQueueSend(color_Queue, &color_date, 0);
                }
                else
                {
                    // error
                }
            }
            else if (sign == 2) // 获取二维码值
            {
                usart_3_date[num + 6] = usart_3_date[num + 7];
                usart_3_date[num + 7] = usart_3_date[num + 8];
                usart_3_date[num + 8] = usart_3_date[num + 9];
                x = 0;
                for (i = 0; i < 6; i++)
                {
                    if (usart_3_date[num + 3 + i] == '1')
                        x |= 0X01 << (5 - i) * 2;
                    else if (usart_3_date[num + 3 + i] == '2')
                        x |= 0X02 << (5 - i) * 2;
                    else if (usart_3_date[num + 3 + i] == '3')
                        x |= 0X03 << (5 - i) * 2;
                    else
                    {
                        x = 0;
                        break;
                    }
                }
                if (x != 0)
                {
                    if ((x & 3 << 0) != ((x & 3 << 2) >> 2) && (x & 3 << 0) != ((x & 3 << 4) >> 4) && (x & 3 << 2) >> 2 != ((x & 3 << 4) >> 4))
                    {

                        color_date.date[3] = x;
                        color_date.date[2] = 22;
                        xQueueSend(color_Queue, &color_date, 0);
                        // printf("%d\n", x);
                    }
                    else
                    {
                        // error
                    }
                }
            }
            else if (sign == 3) // 色环定位数据
            {

                for (i = 0; i < 2; i++)
                {
                    *(f + i) = *(usart_3_date + num + i + 2);
                }
                //          i=*(f);*(f)=*(f+1);*(f+1)=i;

                for (i = 0; i < 2; i++)
                {
                    *(h + i) = *(usart_3_date + num + i + 4);
                }
                for (i = 0; i < 2; i++)
                {
                    *(u + i) = *(usart_3_date + num + i + 6);
                }
                for (i = 0; i < 2; i++)
                {
                    *(q + i) = *(usart_3_date + num + i + 8);
                }
                //          i=*(h);*(h)=*(h+1);*(h+1)=i;
                if ((x != 520 && y != 520) && (y != 9))
                {
                    color_date.date[0] = x;
                    color_date.date[1] = y;
                    color_date.date[2] = 33;
                    color_date.date[3] = 0;
                    xQueueSend(color_Queue, &color_date, 0);
                }
                else
                {
                    // error
                }
            }

            HAL_UART_Receive_DMA(&huart3, usart_3_date, 22);
            xTaskResumeAll();
        }

        // USART6
        if (xSemaphoreTake(usart6_RX_Sem_Handle, 10) == pdTRUE) /* 等待时间 */
        {
            vTaskSuspendAll();
            i = 0;

            for (i = 0; i < 24; i++)
            {
                if (usart_6_date[i] == 0X40 && usart_6_date[i + 8] == 0X0D)
                {
                    sign = 1;
                    break;
                }
                else
                    sign = 0;
            }
            num = i;
            if (sign == 1)
            {
                usart_6_date[num + 4] = usart_6_date[num + 5];
                usart_6_date[num + 5] = usart_6_date[num + 6];
                usart_6_date[num + 6] = usart_6_date[num + 7];
                x = 0;
                for (i = 0; i < 6; i++)
                {
                    if (usart_6_date[num + 1 + i] == '1')
                        x |= 0X01 << (5 - i) * 2;
                    else if (usart_6_date[num + 1 + i] == '2')
                        x |= 0X02 << (5 - i) * 2;
                    else if (usart_6_date[num + 1 + i] == '3')
                        x |= 0X03 << (5 - i) * 2;
                    else
                    {
                        x = 0;
                        break;
                    }
                }
                if (x != 0)
                {
                    if ((x & 3 << 0) != ((x & 3 << 2) >> 2) && (x & 3 << 0) != ((x & 3 << 4) >> 4) && (x & 3 << 2) >> 2 != ((x & 3 << 4) >> 4))
                    {

                        color_date.date[3] = x;
                        color_date.date[2] = 22;
                        xQueueSend(color_Queue, &color_date, 0);
                        // printf("%d\n", x);
                    }
                    else
                    {
                        // error
                    }
                }
            }
            HAL_UART_Receive_DMA(&huart6, usart_6_date, 14);
            xTaskResumeAll();
        }
        osDelay(10);
    }
    /* USER CODE END usart_Task */
}

/* USER CODE BEGIN Header_oled_Task */
/**
 * @brief Function implementing the myTask_oled thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_oled_Task */
float adc_vlaue = 0.0f;
void oled_Task(void const* argument)
{
    /* USER CODE BEGIN oled_Task */
    /* Infinite loop */
    uint32_t ADC_value = 0;

    HAL_ADC_Start_DMA(&hadc1, &ADC_value, 1);
    GPIOD->ODR |= GPIO_PIN_7;
    osDelay(1000);
    GPIOD->ODR &= ~GPIO_PIN_7;
    for (;;)
    {
        adc_vlaue = (float)ADC_value * 3.3f * 11 / 4096.0f;
        // if (adc_vlaue < 11.4f)
        //     GPIOD->ODR |= GPIO_PIN_7;
        // else
        //     GPIOD->ODR &= ~GPIO_PIN_7;
        osDelay(1000);
    }
    /* USER CODE END oled_Task */
}

/* USER CODE BEGIN Header_servo_Task */
/**
 * @brief Function implementing the myTask_servo thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_servo_Task */
void servo_Task(void const* argument)
{
    /* USER CODE BEGIN servo_Task */
    /* Infinite loop */

    uint16_t time = 0;

    static servo_status servo;
    for (;;)
    {
        xQueueReceive(servo_Queue, &servo, portMAX_DELAY);
        if (servo.time == 0)
            time = 1000;
        else
            time = servo.time;

        FSUS_SetServoAngle(servoUsart, 1, servo.value_goal[0], time, 0, 0);
        osDelay(10);
        FSUS_SetServoAngle(servoUsart, 2, servo.value_goal[1], time, 0, 0);
        osDelay(10);
        FSUS_SetServoAngle(servoUsart, 3, servo.value_goal[2], time, 0, 0);
        osDelay(10);
        FSUS_SetServoAngle(servoUsart, 4, servo.value_goal[3], time, 0, 0);
        osDelay(10);

        xSemaphoreGive(Servo_Sem_Handle);

        osDelay(10);
    }
    /* USER CODE END servo_Task */
}

/* USER CODE BEGIN Header_speed_Task */
/**
 * @brief Function implementing the myTask_speed thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_speed_Task */
void speed_Task(void const* argument)
{
    /* USER CODE BEGIN speed_Task */
    /* Infinite loop */
    biu speed;
    static biu distance = { 0, 0, 0, 0 };
    uint8_t i = 0;
    for (;;)
    {
        if (xSemaphoreTake(Distance_Sem_Handle, 0) == pdTRUE)
        {
            for (i = 0; i < 4; i++)
            {
                distance.date[i] = 0;
            }
        }
        vTaskSuspendAll();
        speed.date[0] = TIM2->CNT - 6720;
        TIM2->CNT = 6720;

        speed.date[1] = 6720 - TIM3->CNT;
        TIM3->CNT = 6720;

        speed.date[2] = TIM4->CNT - 6720;
        TIM4->CNT = 6720;

        speed.date[3] = 6720 - TIM5->CNT;
        TIM5->CNT = 6720;
        for (i = 0; i < 4; i++)
        {
            distance.date[i] += speed.date[i];
        }
        xTaskResumeAll();
        xQueueSend(Speed_Queue, &speed, 0); /* 等待时间 0 */
        xQueueSend(distance_Queue, &distance, 0);
        osDelay(5);

    }
    /* USER CODE END speed_Task */
}

/* USER CODE BEGIN Header_pid_Task */
/**
 * @brief Function implementing the myTask_pid thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_pid_Task */
void pid_Task(void const* argument)
{
    /* USER CODE BEGIN pid_Task */
    /* Infinite loop */
    biu speed_goal = { 0 };
    biu speed_now = { 0 };
    speed_ctrl(Motor1, 0);
    speed_ctrl(Motor2, 0);
    speed_ctrl(Motor3, 0);
    speed_ctrl(Motor4, 0);
    for (;;)
    {
        xQueueReceive(Speed_Queue, /* 消息队列的句柄 */
            &speed_now,  /* 发送的消息内容 */
            0);          /* 等待时间 */
        xQueueReceive(goal_Queue,  /* 消息队列的句柄 */
            &speed_goal, /* 发送的消息内容 */
            0);          /* 等待时间 */

        taskENTER_CRITICAL();

        pid_do(speed_goal, speed_now);

        taskEXIT_CRITICAL();

        osDelay(5);

    }
    /* USER CODE END pid_Task */
}

/* USER CODE BEGIN Header_doing_Task */
/**
 * @brief Function implementing the myTask_doing thread.
 * @param argument: Not used
 * @retval None
 */
 /* USER CODE END Header_doing_Task */
int biubiu = L2, fancy = L1;
void doing_Task(void const* argument)
{
    /* USER CODE BEGIN doing_Task */
    /* Infinite loop */

    imu imu_date;            // 陀螺仪数据结构体
    static biu distance_now; // 距离记录结构体
    biu_int_16 color_date;

    float angle_standard = 0.0f;
    float Direction_KP = 1.0f, Direction_KI = 0.02f;
    static int color_speed_use = 0, color_speed_sum1 = 0, color_speed_sum2 = 0, color_speed_dert = 0;
    static int back_sign = 0;
    static int16_t distance_use = 0, color_circle_x = 0, color_circle_y = 0;
    static uint8_t Task_select = Start,
        color_sign = 0,    // 0表示当前正在从原料区拿取第一个物料，1表示当前正在从原料区拿取第二个物料，2表示当前正在从原料区拿取第三个物料,3表示拿取已经结束
        use_num = 0;        // 执行调度参数
    static servo_status servo_time_use = { 0 }, MaxArm_Motion = { 0 },MaxArm_Motion_check = { 0 }, color_circle_find_motion = { 0 };

    int8_t color[6] = { 2, 3, 1, 3, 2, 1 }; // 颜色顺序存储

    uint8_t Arm_do_order = 0, // 表示需要执行动作组的编号
        color_check,
        color_first_find = 0,
        Camera_date_status = 0, // 摄像头数据接收标志位，当串口任务接收到正确的摄像头数据
        // 会通过color_quene消息队列传递数据，doing_task轮询接收，并改变标志位。
        color_sign_now,             // 表示当前原料区扫描检测到的物块颜色
        target_location_sign = 0,
        Do_thing_status = 0,
        i,
        color_location_sign = 0,//色环定位标志位
        angle_num = 0,
        start_status = 0,
        distance_sign = 0,
        MaxArm_check = 0;
    int red_circle_take = 1;
    int green_circle_take = 2;
    int blue_circle_take = 3;
    Uart5_LCD_send_task(0);           // LCD屏幕显示当前任务为开始
    vTaskSuspend(myTask_debugHandle); // 挂起调试任务
    vTaskSuspend(myTask_ledHandle);   // 挂起Led任务
    UNUSED_VARIABLE(distance_use);
    Task_verify = Task_select = To_QR_Code; // 设置当前任务为开始
    speed_CTRL(0, 0, 0, 0);            // 速度归零
    FSUS_SetServoAngle(servoUsart, 6, servo_motion[0].value_goal[4], 1000, 0, 0);
    osDelay(10);
    servo_all_move(servo_motion[0]);

    for (;;)
    {

        if (xQueueReceive(angle_Queue, &imu_date, 0) == pdTRUE) // 接收偏航角数据
        {
            angle_num++;
            if (angle_num > 5) // 每250毫秒更新一次LCD屏幕上的偏航角数据
            {
                angle_num = 0;
                Uart5_LCD_show_Angle(imu_date.IMU[2]);
            }
        }

        if (xQueueReceive(distance_Queue, &distance_now, 0) == pdTRUE) // 接收当前轮子所走过的距离
        {
            distance_sign = 1;
        }
        if (xQueueReceive(color_Queue, &color_date, 0) == pdTRUE) // 获取颜色顺序
        {
            Camera_date_status = 1;
            if (color_date.date[2] == 33)
            {
                use_num++;
                color_date.date[0] = -color_date.date[0];
                color_date.date[1] = -color_date.date[1];
                Uart5_LCD_show_X_Y(color_date.date[0], color_date.date[1]);
            }
        }

        if (xSemaphoreTake(Servo_Sem_Handle, 1) == pdTRUE) // 上次动作组已经执行完毕
        {
            servo_sign = 1;
        }
        if (xSemaphoreTake(key_start_Sem_Handle, 0) == pdTRUE) // 按键触发启动任务
        {
            osDelay(1000);
            GM65_work(); // 发送指令到GM65执行二维码扫描
            start_status = 1;
            vTaskResume(myTask_ledHandle); // LED闪烁任务启动
        }
        if (xSemaphoreTake(key_stop_Sem_Handle, 0) == pdTRUE)  // 按键触发停止任务
        {
            start_status = 0;
            vTaskSuspend(myTask_ledHandle);
        }
        if (xSemaphoreTake(key_debug_Sem_Handle, 0) == pdTRUE) // 按键触发调试任务
        {
            start_status = 1;
            Task_verify = Task_select = Angle_direction_2;
        }
        if (start_status == 0)
        {
            if (i > 100)
            {
//                Camera_Color_Find_do();
                i = 0;
            }
            i++;
            speed_CTRL(0, 0, 0, 0);            // 速度归零
            osDelay(10);
            continue; // 退出本次循环，不再执行下面的所有代码
        }

//        Task_select = Task_select == Task_verify ? Task_select : Task_verify; // 校验任务选择变量有没有出错

        switch (Task_select)
        {
 
        case To_QR_Code:                                                                  // 前进到二维码区域
            if (Directional_move_distance(angle_standard, imu_date, distance_now, 900,80) == 1) // 前进 440 mm到达二维码扫描区
            {
                speed_CTRL(0, 0, 0, 0);   // 刹车
                vTaskSuspendAll();        // 进入临界区
                Task_select = At_QR_Code; // 任务跳转
                Task_verify = At_QR_Code;
                Uart5_LCD_show_string("At_QR_Code");
                xTaskResumeAll();
            }
            break;
        
        case At_QR_Code:                 // 扫描二维码
            if (Camera_date_status == 0) // 如果摄像头标志位未触发
            {
                GM65_work(); // 串口指令使能GM65
                osDelay(200);
            }
            else
            {
                if (color_date.date[2] != 22) // 如果收到的数据有问题
                {
                    Camera_die(); // 关机（重启）
                    Camera_date_status = 0;
                }
                else // 没啥问题
                {
                    speed_CTRL(0, 0, 0, 0);                            // 刹车
                    vTaskSuspendAll();                                 // 临界区
                    color[0] = (color_date.date[3] & (3 << 10)) >> 10; // 数据读取
                    color[1] = (color_date.date[3] & (3 << 8)) >> 8;
                    color[2] = (color_date.date[3] & (3 << 6)) >> 6;
                    color[3] = (color_date.date[3] & (3 << 4)) >> 4;
                    color[4] = (color_date.date[3] & (3 << 2)) >> 2;
                    color[5] = (color_date.date[3] & (3 << 0)) >> 0;
                    Uart5_LCD_show_QR(color[0], color[1], color[2], color[3], color[4], color[5]); // LCD显示二维码数据
                    xTaskResumeAll();
                    Camera_die(); // 关机吧
                    osDelay(10);
                    vTaskSuspendAll();
                    Task_select = To_RMA; // 任务跳转
                    Task_verify = To_RMA;

                    Camera_date_status = 0; // 摄像头标志位归零
                    Uart5_LCD_show_string("To_RMA");
                    xTaskResumeAll();
                }
            }
            break;
        case To_RMA:                                                                      // 前进到达暂存区
            if (advance_angle_distance(angle_standard, imu_date, distance_now, 780) == 1) // 前进 845 mm  , 当原料区距离修改时，第一转角距离也需要修改
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Task_select = At_RMA1;
                Task_verify = At_RMA1;
                Uart5_LCD_show_string("At_RMA1");
                Camera_date_status = 0;
                xTaskResumeAll();
            }
            break;
        case At_RMA1: // 达到第一个拐角
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Task_select = Start;
                Task_verify = Start;
                Uart5_LCD_show_string("Do_capture");
                color_first_find = 0;
                GM65_work(); // 发送指令到GM65执行二维码扫描
                xTaskResumeAll();

            }
            break;
        case Start:// 向右走 到达暂存区
            if (distance_sign == 1)
            {
                if (crosswise_angle_distance(angle_standard, imu_date, distance_now, 910) == 1)
                {
                    speed_CTRL(0, 0, 0, 0);
                    Task_select = Task_verify = Debug; // 跳转任务
                    Uart5_LCD_show_string("To_QR_Code");
                    GM65_work(); // 发送指令到GM65执行二维码扫描
                    Camera_Color_Find_do();
                    Arm_do_order = color_sign = servo_sign = 0;
                    Camera_Color_Find_do();
                }
                distance_sign = 0;
            }
            break;
        case Debug:
            switch(Arm_do_order)
            {
                case 0:
                    Camera_Color_Find_do();
                    color_circle_find_motion = servo_motion[38];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    osDelay(1000);
                    xQueueReceive(color_Queue, &color_date, 0);
                    Arm_do_order++;
                    break;
                case 1:
                    if(Camera_date_status==1)
                    {
                        red_circle_take=color_date.date[1];
                        Camera_date_status=0;
                        Arm_do_order++;
                    }
                    break;
                case 2:
                    Camera_Color_Find_do();
                    color_circle_find_motion = servo_motion[37];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    osDelay(1000);
                    xQueueReceive(color_Queue, &color_date, 0);
                    Arm_do_order++;
                    break;
                case 3:
                    if(Camera_date_status==1)
                    {
                        green_circle_take=color_date.date[1];
                        Camera_date_status=0;
                        Arm_do_order++;
                    }
                    break;
                case 4:
                    Camera_Color_Find_do();
                    color_circle_find_motion = servo_motion[36];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    osDelay(1000);
                    xQueueReceive(color_Queue, &color_date, 0);
                    Arm_do_order++;
                    break;
                case 5:
                    if(Camera_date_status==1)
                    {
                        blue_circle_take=color_date.date[1];
                        Camera_date_status=0;
                        Arm_do_order++;
                    }
                    break;
                case 6:
                    servo_all_move(servo_motion[1]);
                    osDelay(1000);
                    Arm_do_order = color_sign = servo_sign = 0;
                    Task_select = Task_verify = At_Put_down_2_0; // 跳转任务
                    break;
                    
            }
            break;
        
        case At_Put_down_2_0: // 暂存区视觉定位
        {
            if (color_location_sign == 0)
            {
                switch (green_circle_take)
                {
                    case 1:
                        Camera_color_Stacking_Red();
                        break;
                    case 2:
                        Camera_color_Stacking_Green();
                        break;
                    case 3:
                        Camera_color_Stacking_Blue();
                        break;
                }
                vTaskSuspendAll();
                back_sign = At_Put_down_2_0;
                if (Camera_date_status == 1 && color_date.date[2] == 33)
                {
                    color_circle_x = color_circle_x_TX;
                    color_circle_y = color_circle_y_TX;
                    Task_select = Color_cicle_location;
                    Task_verify = Color_cicle_location;
                    back_sign = At_Put_down_2_0;
                    Camera_date_status = 0;
                }
                else
                {
                    switch (green_circle_take)
                    {
                        case 1:
                            Camera_color_Stacking_Red();
                            break;
                        case 2:
                            Camera_color_Stacking_Green();
                            break;
                        case 3:
                            Camera_color_Stacking_Blue();
                            break;
                    }
                }

                xTaskResumeAll();
            }
            else
            {
                vTaskSuspendAll();
                color_location_sign = 0;

                Arm_do_order = color_sign = servo_sign = 0;
                Task_select = Take_color_thing;
                Task_verify = Take_color_thing;

                xTaskResumeAll();
            }
            break;
        }
        case Take_color_thing: // 在暂存区 拿取物料任务
            switch (Arm_do_order)
            {
            case 0:
                if (color[color_sign]==red_circle_take) // 红色
                {
                    servo_all_move(servo_motion[44]);
                    osDelay(servo_motion[44].time + 70);
                    servo_all_move(servo_motion[41]);
                    osDelay(servo_motion[41].time + 70);

//                    servo_time_use = servo_motion[20];
//                    servo_time_use.time = 300;
//                    servo_all_move(servo_time_use);
//                    osDelay(servo_time_use.time);
                    Arm_do_order++;
                }
                if (color[color_sign]==green_circle_take) // 绿色
                {
                    servo_all_move(servo_motion[45]);
                    osDelay(servo_motion[45].time + 70);
                    servo_all_move(servo_motion[42]);
                    osDelay(servo_motion[42].time + 70);

//                    servo_time_use = servo_motion[17];
//                    servo_time_use.time = 300;
//                    servo_all_move(servo_time_use);
//                    osDelay(servo_time_use.time);
                    Arm_do_order++;
                }
                if (color[color_sign]==blue_circle_take) // 蓝色
                {
                    servo_all_move(servo_motion[46]);
                    osDelay(servo_motion[46].time + 70);
                    servo_all_move(servo_motion[43]);
                    osDelay(servo_motion[43].time + 70);

//                    servo_time_use = servo_motion[23];
//                    servo_time_use.time = 300;
//                    servo_all_move(servo_time_use);
//                    osDelay(servo_time_use.time);
                    Arm_do_order++;
                }
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                
                servo_time_use = servo_motion[16];
                servo_time_use.time = 800;
                servo_all_move(servo_time_use);
                osDelay(servo_time_use.time);
                
                
                Arm_do_order++;
                color_sign++;
                break;
            case 2:
                servo_all_move(servo_motion[6]);
                osDelay(servo_motion[6].time + 70);
                servo_all_move(servo_motion[7]);
                osDelay(servo_motion[7].time + 70);
                servo_all_move(servo_motion[8]);
                osDelay(servo_motion[8].time + 70);
                servo_all_move(servo_motion[9]);
                osDelay(servo_motion[9].time + 70);
                servo_all_move(servo_motion[10]);
                osDelay(servo_motion[10].time + 70);

                if (color_sign >= 3)
                {
                    Arm_do_order = 234;
                }
                else
                {
                    Arm_do_order = 0;
                    servo_all_move(servo_motion[26]);
                    osDelay(servo_motion[26].time + 70);
                }
                break;
            default:
                Task_select = Task_verify = To_Put_down_3;
                angle_standard=-90.2;
                break;
            }
            break;
            
        case To_Put_down_3: // 在暂存区调整车身角度 
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                osDelay(100);

                vTaskSuspendAll();
                servo_all_move(servo_motion[1]);
                Task_select = To_Turn_1;
                Task_verify = To_Turn_1;
                color_location_sign = 0;
                Arm_do_order = color_sign = servo_sign = 0;
                color_date.date[2] = 0;
                Camera_date_status = 0;
                xTaskResumeAll();

            }
            break;
        case To_Turn_1: //前往粗加工区域
            if (advance_angle_distance(angle_standard, imu_date, distance_now, 800) == 1) //
            {

                vTaskSuspendAll();
                Task_select = Task_verify = To_Put_down_1;
                xTaskResumeAll();
            }
            break;
        case To_Put_down_1:    // 达到粗加工区
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, 635) == 1) //
            {

                vTaskSuspendAll();
                Task_select = Task_verify = Angle_direction_2;
                xTaskResumeAll();
            }
            break;
        case Angle_direction_2: // 在粗加工区进行方向调整
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Task_select = At_Put_down_1_1;
                Task_verify = At_Put_down_1_1;
                servo_all_move(servo_motion[1]);
                color_location_sign = 0;
                Arm_do_order = color_sign = servo_sign = 0;
                if (Do_thing_status == 1)
                    color_sign = 3;

                xTaskResumeAll();
            }
            break;

        case At_Put_down_1_1: // 粗加工区视觉定位
        {
            if (color_location_sign == 0)
            {
                Color_circle_location();
                vTaskSuspendAll();
                back_sign = At_Put_down_1_1;
                if (Camera_date_status == 1 && color_date.date[2] == 33)
                {
                    color_circle_x = color_circle_x_RM;
                    color_circle_y = color_circle_y_RM;
                    Task_select = Color_cicle_location;
                    Task_verify = Color_cicle_location;
                    back_sign = At_Put_down_1_1;
                }
                else
                {
                    Color_circle_location();
                }

                xTaskResumeAll();
            }
            else
            {
                vTaskSuspendAll();
                color_location_sign = 0;
                Arm_do_order = color_sign = servo_sign = 0;
                if (Do_thing_status == 1)
                    color_sign = 3;
                Task_select = At_Put_down_1_angle;
                Task_verify = At_Put_down_1_angle;
                xTaskResumeAll();
            }
            break;
        }
        case At_Put_down_1_angle:
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                
                Camera_die();
                Task_select = At_Put_down_1_2;
                Task_verify = At_Put_down_1_2;
                xTaskResumeAll();
            }
            break;
        case At_Put_down_1_2: // 在粗加工区 放置物料,色环
            switch (Arm_do_order)
            {
            case 0:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                servo_all_move(servo_motion[12]);
                osDelay(servo_motion[12].time + 70);
                servo_all_move(servo_motion[13]);
                osDelay(servo_motion[13].time + 70);
                servo_all_move(servo_motion[14]);
                osDelay(servo_motion[14].time + 70);
                servo_all_move(servo_motion[15]);
                osDelay(servo_motion[15].time + 70);
                servo_all_move(servo_motion[16]);
                osDelay(servo_motion[16].time + 70);
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 红色
                    Arm_do_order++;
                    Camera_color_circle_Red();
                    osDelay(50);
                    Camera_color_circle_Red();
                    osDelay(70);
                    Camera_color_circle_Red();
                    break;
                case 2: // 绿色
                    Arm_do_order++;
                    Camera_color_circle_Green();
                    osDelay(50);
                    Camera_color_circle_Green();
                    osDelay(70);
                    Camera_color_circle_Green();

                    break;
                case 3: // 蓝色
                    Arm_do_order++;
                    Camera_color_circle_Blue();
                    osDelay(50);
                    Camera_color_circle_Blue();
                    osDelay(70);
                    Camera_color_circle_Blue();
                    break;
                }

                break;
            case 2:
                switch (color[color_sign])
                {
                case red_circle: // 红色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[38];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    break;
                case green_circle: // 绿色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[37];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);

                    break;
                case blue_circle: // 蓝色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[36];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    break;
                }

                break;
            case 3:
                if (Camera_date_status == 1)
                {
                    switch (color[color_sign])
                    {
                    case red_circle:
                        MaxArm_Motion = CR_Arm_adjust_red(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    case green_circle:
                        MaxArm_Motion = CR_Arm_adjust_green(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    case blue_circle:
                        MaxArm_Motion = CR_Arm_adjust_blue(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    }
                }
                else
                {
                    color_check++;
                    if (color_check > 5)
                    {
                        switch (color[color_sign])
                        {
                        case 1: // 红色

                            Camera_color_circle_Red();
                            break;
                        case 2: // 绿色

                            Camera_color_circle_Green();

                            break;
                        case 3: // 蓝色

                            Camera_color_circle_Blue();
                            break;
                        }
                        color_check = 0;
                    }
                }
                break;
            case 4:
                switch (color[color_sign])
                {
                case red_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_red(Red_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_red(110, Red_Get_W, MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                case green_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion_check=MaxArm_Motion;
                    MaxArm_Motion = MaxArm_landing_green(Green_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    if(abs((int)(MaxArm_Motion.value_goal[0]-servo_motion[37].value_goal[0]))>30)
                    {
                        MaxArm_Motion = MaxArm_landing_green(Green_Put_H, color_date.date[1], MaxArm_Motion_check);
                    }
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = servo_motion[19];
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                case blue_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_blue(Blue_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_blue(110, Blue_Get_W, MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                }
                color_sign++;
                Arm_do_order = 0;
                xQueueReceive(color_Queue, &color_date, 10);
                Camera_date_status = 0;
                if (color_sign >= 3)
                    Arm_do_order = 234;
                break;
            default:
                Task_select = Task_verify = At_Put_down_1_3;
                Arm_do_order = color_sign = servo_sign = 0;
                break;
            }
            break;
        case At_Put_down_1_3: // 在粗加工区把放下的物料拿起来
            switch (Arm_do_order)
            {
            case 0:
                switch (color[color_sign])
                {
                case red_circle: // 红色
                    servo_all_move(servo_motion[44]);
                    osDelay(servo_motion[44].time + 70);
                    servo_all_move(servo_motion[41]);
                    osDelay(servo_motion[41].time + 70);

                    
                    break;
                case green_circle: // 绿色
                    servo_all_move(servo_motion[45]);
                    osDelay(servo_motion[45].time + 70);
                    servo_all_move(servo_motion[42]);
                    osDelay(servo_motion[42].time + 70);

                    

                    break;
                case blue_circle: // 蓝色
                    servo_all_move(servo_motion[46]);
                    osDelay(servo_motion[46].time + 70);
                    servo_all_move(servo_motion[43]);
                    osDelay(servo_motion[43].time + 70);

                    

                    break;
                }
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                
                servo_time_use = servo_motion[16];
                servo_time_use.time = 800;
                servo_all_move(servo_time_use);
                osDelay(servo_time_use.time);
                
                
                Arm_do_order++;
                color_sign++;
                break;
            case 2:
                servo_all_move(servo_motion[6]);
                osDelay(servo_motion[6].time + 70);
                servo_all_move(servo_motion[7]);
                osDelay(servo_motion[7].time + 70);
                servo_all_move(servo_motion[8]);
                osDelay(servo_motion[8].time + 70);
                servo_all_move(servo_motion[9]);
                osDelay(servo_motion[9].time + 70);
                servo_all_move(servo_motion[10]);
                osDelay(servo_motion[10].time + 70);

                if (color_sign >= 3)
                {
                    Arm_do_order = 234;
                }
                else
                {
                    Arm_do_order = 0;
                    servo_all_move(servo_motion[26]);
                    osDelay(servo_motion[26].time + 70);
                }
                break;
            default:
                Task_select = Task_verify = To_Turn_2;
                break;
            }
            break;
        case To_Turn_2:// 右行前往成品区
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, 920) == 1) //
            {
                vTaskSuspendAll();
                Task_select = Task_verify = At_Turn_2_angle;
                servo_all_move(servo_motion[2]);
                xTaskResumeAll();
            }
            break;
        case At_Turn_2_angle:
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Camera_die();
                Task_select = At_Turn_2;
                Task_verify = At_Turn_2;
                xTaskResumeAll();
            }
            break;
        case At_Turn_2:// 直线前进到达成品区
            if (advance_angle_distance(angle_standard, imu_date, distance_now, -1435) == 1) //
            {
                vTaskSuspendAll();
                Task_select = Task_verify = Start_Calibration;
                servo_all_move(servo_motion[12]);
                color_sign = Arm_do_order = 0;
                xTaskResumeAll();
            }
            break;  
        case Start_Calibration:
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                color_sign = Arm_do_order = 0;
                Task_select = At_Put_down_2_1;
                Task_verify = At_Put_down_2_1;
                xTaskResumeAll();
            }
            break;
            
        case At_Put_down_2_1: //成品区放置物料           
            {        
                switch (Arm_do_order)
                {
                case 0:
                    switch (color[color_sign])
                    {
                    case 1: // 识别到的红色物料放置
                        FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                        break;
                    case 2: // 识别到的绿色物料放置
                        FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                        break;
                    case 3: // 识别到的蓝色物料放置
                        FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                        break;
                    }
                    osDelay(10);
                    servo_all_move(servo_motion[12]);
                    osDelay(servo_motion[12].time + 70);
                    servo_all_move(servo_motion[13]);
                    osDelay(servo_motion[13].time + 70);
                    servo_all_move(servo_motion[14]);
                    osDelay(servo_motion[14].time + 70);
                    servo_all_move(servo_motion[15]);
                    osDelay(servo_motion[15].time + 70);
                    servo_all_move(servo_motion[47]);
                    osDelay(servo_motion[47].time + 70);
                    Arm_do_order++;
                    break;
                case 1:
                    switch (color[color_sign])
                    {
                    case 1: // 红色
                        Arm_do_order++;
                        Camera_Color_Find_do();
                        osDelay(50);
                        Camera_Color_Find_do();
                        osDelay(70);
                        Camera_Color_Find_do();
                        break;
                    case 2: // 绿色
                        Arm_do_order++;
                        Camera_Color_Find_do();
                        osDelay(50);
                        Camera_Color_Find_do();
                        osDelay(70);
                        Camera_Color_Find_do();

                        break;
                    case 3: // 蓝色
                        Arm_do_order++;
                        Camera_Color_Find_do();
                        osDelay(50);
                        Camera_Color_Find_do();
                        osDelay(70);
                        Camera_Color_Find_do();
                        break;
                    }
                    break;
                case 2:
                    if (Camera_date_status == 1)
                    {
                        switch (color[color_sign])
                        {
                        case 1: // 红色                        
                            if(color[color_sign] == color_date.date[1])
                            {
                                servo_all_move(servo_motion[48]);
                                osDelay(servo_motion[48].time + 70);
                                servo_all_move(servo_motion[49]);
                                osDelay(servo_motion[49].time + 70);
                                servo_all_move(servo_motion[50]);
                                osDelay(servo_motion[50].time + 70);
                                Arm_do_order++;
                            }
                            break;
                        case 2: // 绿色                        
                            if(color[color_sign] == color_date.date[1])
                            {
                                servo_all_move(servo_motion[48]);
                                osDelay(servo_motion[48].time + 70);
                                servo_all_move(servo_motion[49]);
                                osDelay(servo_motion[49].time + 70);
                                servo_all_move(servo_motion[50]);
                                osDelay(servo_motion[50].time + 70);
                                Arm_do_order++;
                            }
                            break;
                        case 3: // 蓝色                        
                            if(color[color_sign] == color_date.date[1])
                            {
                                servo_all_move(servo_motion[48]);
                                osDelay(servo_motion[48].time + 70);
                                servo_all_move(servo_motion[49]);
                                osDelay(servo_motion[49].time + 70);
                                servo_all_move(servo_motion[50]);
                                osDelay(servo_motion[50].time + 70);
                                Arm_do_order++;
                            }
                            break;  
                        }
                        Camera_date_status=0;
                    }
                    break;
                case 3:
                    if(color_sign>=2)
                    {
                        Arm_do_order=12;
                    }
                    else
                    {
                        Arm_do_order=0;
                        color_sign++;
                    }
                    break;
                default:
                    Task_select = Task_verify = Adjust_position;
                    Camera_die();
                    servo_all_move(servo_motion[2]);
                    Uart5_LCD_show_string("To_Turn_1");
                    break;
                }
            }
            break;
    
        case Adjust_position:
            if (advance_angle_distance(angle_standard, imu_date, distance_now, 800) == 1) //
            {

                vTaskSuspendAll();
                angle_standard = 0.0;
                servo_all_move(servo_motion[2]);
                Task_select = Task_verify = Back_Take_thing_1;
                xTaskResumeAll();
            }
            break;

        case Back_Take_thing_1: 
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, -920) == 1) //
            {

                vTaskSuspendAll();
                Task_select = Task_verify = To_Put_down_2;
                xTaskResumeAll();
            }
            break;
        case To_Put_down_2:  
            if (advance_angle_distance(angle_standard, imu_date, distance_now, -800) == 1) 
            {
                speed_CTRL(0, 0, 0, 0);
                osDelay(200);
                vTaskSuspendAll();
                Task_select = Back_Take_thing_2;
                Task_verify = Back_Take_thing_2;
                angle_standard=0;
                xTaskResumeAll();
            }
            break;
        case Back_Take_thing_2: 
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                color_first_find = 0;
                Stack_circle_location(); // 开始扫描物块颜色
                servo_all_move(servo_motion[1]);
                Uart5_LCD_show_string("Take_color_thing_2");
                Task_select = Back_Take_thing_3;
                Task_verify = Back_Take_thing_3;
                Camera_date_status = 0;
                xTaskResumeAll();
            }
            break;

        case Back_Take_thing_3:   //向后走一段
            if (advance_angle_distance(angle_standard, imu_date, distance_now, 100) == 1) //
            {

                vTaskSuspendAll();
                Do_thing_status = 1;
                servo_all_move(servo_motion[1]);
                Task_select = Task_verify = Angle_direction_3;
                Uart5_LCD_show_string("Angle_direction_3");
                xTaskResumeAll();
            }
            break;

        case Angle_direction_3: // 第二次在暂存区定位
        {
            if (color_location_sign == 0)
            {
                Stack_circle_location(); // 开始扫描物块颜色
                vTaskSuspendAll();
                back_sign = Angle_direction_3;
                if (Camera_date_status == 1 && color_date.date[2] == 33)
                {
                    color_circle_x = color_circle_x_TX;
                    color_circle_y = color_circle_y_TX;
                    Task_select = Color_cicle_location;
                    Task_verify = Color_cicle_location;
                    back_sign = Angle_direction_3;
                    Camera_date_status = 0;
                }
                else
                {
                    Color_circle_location();
                }

                xTaskResumeAll();
            }
            else
            {
                vTaskSuspendAll();
                color_location_sign = 0;

                Arm_do_order  = servo_sign = 0;
                color_sign=3;
                Task_select = Take_color_thing_2;
                Task_verify = Take_color_thing_2;

                xTaskResumeAll();
            }
            break;
        }

        case Take_color_thing_2: // 第二次在暂存区拿物料
            switch (Arm_do_order)
            {
            case 0:
                if (color[color_sign]==red_circle_take) // 红色
                {
                    servo_all_move(servo_motion[44]);
                    osDelay(servo_motion[44].time + 70);
                    servo_all_move(servo_motion[41]);
                    osDelay(servo_motion[41].time + 70);

                    servo_time_use = servo_motion[20];
                    servo_time_use.time = 300;
                    servo_all_move(servo_time_use);
                    osDelay(servo_time_use.time);

                    break;
                }
                if (color[color_sign]==green_circle_take) // 绿色
                {
                    servo_all_move(servo_motion[45]);
                    osDelay(servo_motion[45].time + 70);
                    servo_all_move(servo_motion[42]);
                    osDelay(servo_motion[42].time + 70);

                    servo_time_use = servo_motion[17];
                    servo_time_use.time = 300;
                    servo_all_move(servo_time_use);
                    osDelay(servo_time_use.time);

                    break;
                }
                    if (color[color_sign]==blue_circle_take) // 蓝色
                    {
                        servo_all_move(servo_motion[46]);
                        osDelay(servo_motion[46].time + 70);
                        servo_all_move(servo_motion[43]);
                        osDelay(servo_motion[43].time + 70);

                        servo_time_use = servo_motion[23];
                        servo_time_use.time = 300;
                        servo_all_move(servo_time_use);
                        osDelay(servo_time_use.time);

                        break;
                    }
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                
                servo_time_use = servo_motion[16];
                servo_time_use.time = 800;
                servo_all_move(servo_time_use);
                osDelay(servo_time_use.time);
                
                
                Arm_do_order++;
                color_sign++;
                break;
            case 2:
                servo_all_move(servo_motion[6]);
                osDelay(servo_motion[6].time + 70);
                servo_all_move(servo_motion[7]);
                osDelay(servo_motion[7].time + 70);
                servo_all_move(servo_motion[8]);
                osDelay(servo_motion[8].time + 70);
                servo_all_move(servo_motion[9]);
                osDelay(servo_motion[9].time + 70);
                servo_all_move(servo_motion[10]);
                osDelay(servo_motion[10].time + 70);

                if (color_sign >= 6)
                {
                    Arm_do_order = 234;
                }
                else
                {
                    Arm_do_order = 0;
                    servo_all_move(servo_motion[26]);
                    osDelay(servo_motion[26].time + 70);
                }
                break;
            default:
                Task_select = Task_verify = Take_color_thing_2_1;
                angle_standard=-90.2;
                break;
            }
            break;
        case Take_color_thing_2_1:
           if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                
                Camera_die();
                Task_select = S_To_Turn_1;
                Task_verify = S_To_Turn_1;
                xTaskResumeAll();
            }
            break;
        case S_To_Turn_1: // 直线前进
            Uart5_LCD_show_string("To_Turn_1");
            if (advance_angle_distance(angle_standard, imu_date, distance_now, 800) == 1) // 向前前往转向1
            {
                Uart5_LCD_show_string("To_Put_down_1");
                Task_select = Task_verify = S_To_Put_down_1;
            }
            break;
        case S_To_Put_down_1:                                                                  // 右行达到粗加工区
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, 675) == 1) // 放下1
            {

                vTaskSuspendAll();
                Task_select = Task_verify = S_Angle_direction_2;
                servo_all_move(servo_motion[1]);
                xTaskResumeAll();
            }
            break;
        case S_Angle_direction_2: // 在粗加工区进行方向调整
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Task_select = S_At_Put_down_1_1;
                Task_verify = S_At_Put_down_1_1;
                servo_all_move(servo_motion[1]);
                color_location_sign = 0;
                Arm_do_order = color_sign = servo_sign = 0;

                color_sign = 3;

                xTaskResumeAll();
            }
            break;

        case S_At_Put_down_1_1: // 粗加工区视觉定位
        {
            if (color_location_sign == 0)
            {
                Color_circle_location();
                vTaskSuspendAll();
                back_sign = S_At_Put_down_1_1;
                if (Camera_date_status == 1 && color_date.date[2] == 33)
                {
                    color_circle_x = color_circle_x_RM;
                    color_circle_y = color_circle_y_RM;
                    Task_select = Color_cicle_location;
                    Task_verify = Color_cicle_location;
                    back_sign = S_At_Put_down_1_1;
                }
                else
                {
                    Color_circle_location();
                }

                xTaskResumeAll();
            }
            else
            {
                vTaskSuspendAll();
                color_location_sign = 0;
                Arm_do_order = servo_sign = 0;
                color_sign = 3;
                Task_select = S_At_Put_down_1_2;
                Task_verify = S_At_Put_down_1_2;
                xTaskResumeAll();
            }
            break;
        }

        case S_At_Put_down_1_2: // 在粗加工区 放置物料,色环
            switch (Arm_do_order)
            {
            case 0:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                servo_all_move(servo_motion[12]);
                osDelay(servo_motion[12].time + 70);
                servo_all_move(servo_motion[13]);
                osDelay(servo_motion[13].time + 70);
                servo_all_move(servo_motion[14]);
                osDelay(servo_motion[14].time + 70);
                servo_all_move(servo_motion[15]);
                osDelay(servo_motion[15].time + 70);
                servo_all_move(servo_motion[16]);
                osDelay(servo_motion[16].time + 70);
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 红色
                    Arm_do_order++;
                    Camera_color_circle_Red();
                    osDelay(50);
                    Camera_color_circle_Red();
                    osDelay(70);
                    Camera_color_circle_Red();
                    break;
                case 2: // 绿色
                    Arm_do_order++;
                    Camera_color_circle_Green();
                    osDelay(50);
                    Camera_color_circle_Green();
                    osDelay(70);
                    Camera_color_circle_Green();

                    break;
                case 3: // 蓝色
                    Arm_do_order++;
                    Camera_color_circle_Blue();
                    osDelay(50);
                    Camera_color_circle_Blue();
                    osDelay(70);
                    Camera_color_circle_Blue();
                    break;
                }

                break;
            case 2:
                switch (color[color_sign])
                {
                case red_circle: // 红色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[38];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    break;
                case green_circle: // 绿色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[37];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);

                    break;
                case blue_circle: // 蓝色
                    Arm_do_order++;
                    color_circle_find_motion = servo_motion[36];
                    servo_all_move(color_circle_find_motion);
                    osDelay(color_circle_find_motion.time + 70);
                    break;
                }

                break;
            case 3:
                if (Camera_date_status == 1)
                {
                    switch (color[color_sign])
                    {
                    case red_circle:
                        MaxArm_Motion = CR_Arm_adjust_red(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    case green_circle:
                        MaxArm_Motion = CR_Arm_adjust_green(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    case blue_circle:
                        MaxArm_Motion = CR_Arm_adjust_blue(color_date, color_circle_find_motion);
                        if (MaxArm_Motion.sign == 1)
                        {
                            if (MaxArm_check > 5)
                            {
                                Arm_do_order++;
                                MaxArm_check = 0;
                            }
                            osDelay(100);
                            MaxArm_Motion.sign = 0;
                            MaxArm_check++;
                        }
                        xQueueReceive(color_Queue, &color_date, 10);
                        Camera_date_status = 0;
                        break;
                    }
                }
                else
                {
                    color_check++;
                    if (color_check > 5)
                    {
                        switch (color[color_sign])
                        {
                        case 1: // 红色

                            Camera_color_circle_Red();
                            break;
                        case 2: // 绿色

                            Camera_color_circle_Green();

                            break;
                        case 3: // 蓝色

                            Camera_color_circle_Blue();
                            break;
                        }
                        color_check = 0;
                    }
                }
                break;
            case 4:
                switch (color[color_sign])
                {
                case red_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_red(Red_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_red(110, Red_Get_W, MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                case green_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion_check = MaxArm_Motion;
                    MaxArm_Motion = MaxArm_landing_green(Green_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    if (abs((int)(MaxArm_Motion.value_goal[0] - servo_motion[37].value_goal[0])) > 30)
                    {
                        MaxArm_Motion = MaxArm_landing_green(Green_Put_H, color_date.date[1], MaxArm_Motion_check);
                    }
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = servo_motion[19];
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                case blue_circle:
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_blue(Blue_Put_H, color_date.date[1], MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();

                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    MaxArm_Motion.time = 500;
                    MaxArm_Motion.value_goal[3] = -45.7;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    vTaskSuspendAll();
                    MaxArm_Motion = MaxArm_landing_blue(110, Blue_Get_W, MaxArm_Motion);
                    MaxArm_Motion.time = 500;
                    xTaskResumeAll();
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);
                    break;
                }
                color_sign++;
                Arm_do_order = 0;
                xQueueReceive(color_Queue, &color_date, 10);
                Camera_date_status = 0;
                if (color_sign >= 6)
                    Arm_do_order = 234;
                break;
            default:
                Task_select = Task_verify = S_At_Put_down_1_3;
                Arm_do_order = servo_sign = 0;
                color_sign = 3;
                break;
            }
            break;
        case S_At_Put_down_1_3: // 在粗加工区把放下的物料拿起来
            switch (Arm_do_order)
            {
            case 0:
                switch (color[color_sign])
                {
                case red_circle: // 红色
                    servo_all_move(servo_motion[22]);
                    osDelay(servo_motion[22].time + 70);
                    servo_all_move(servo_motion[21]);
                    osDelay(servo_motion[21].time + 70);


                    servo_time_use = servo_motion[20];
                    servo_time_use.time = 300;
                    servo_all_move(servo_time_use);
                    osDelay(servo_time_use.time);

                    break;
                case green_circle: // 绿色
                    servo_all_move(servo_motion[19]);
                    osDelay(servo_motion[19].time + 70);
                    servo_all_move(servo_motion[18]);
                    osDelay(servo_motion[18].time + 70);

                    servo_time_use = servo_motion[17];
                    servo_time_use.time = 300;
                    servo_all_move(servo_time_use);
                    osDelay(servo_time_use.time);

                    break;
                case blue_circle: // 蓝色
                    servo_all_move(servo_motion[25]);
                    osDelay(servo_motion[25].time + 70);
                    servo_all_move(servo_motion[24]);
                    osDelay(servo_motion[24].time + 70);

                    servo_time_use = servo_motion[23];
                    servo_time_use.time = 300;
                    servo_all_move(servo_time_use);
                    osDelay(servo_time_use.time);

                    break;
                }
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Red_Rotary_table, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Green_Rotary_table, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, Blue_Rotary_table, 1000, 0, 0);
                    break;
                }
                osDelay(10);

                servo_time_use = servo_motion[16];
                servo_time_use.time = 800;
                servo_all_move(servo_time_use);
                osDelay(servo_time_use.time);


                Arm_do_order++;
                color_sign++;
                break;
            case 2:
                servo_all_move(servo_motion[6]);
                osDelay(servo_motion[6].time + 70);
                servo_all_move(servo_motion[7]);
                osDelay(servo_motion[7].time + 70);
                servo_all_move(servo_motion[8]);
                osDelay(servo_motion[8].time + 70);
                servo_all_move(servo_motion[9]);
                osDelay(servo_motion[9].time + 70);
                servo_all_move(servo_motion[10]);
                osDelay(servo_motion[10].time + 70);

                if (color_sign >= 6)
                {
                    Arm_do_order = 234;
                }
                else
                {
                    Arm_do_order = 0;
                    servo_all_move(servo_motion[26]);
                    osDelay(servo_motion[26].time + 70);
                }
                break;
            default:
                Task_select = Task_verify = S_To_Turn_2;
                break;
            }
            break;
        case S_To_Turn_2:                                                                      // 左行前往暂存区
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, Rough_TS_left_2) == 1) //
            {
                vTaskSuspendAll();
                Task_select = Task_verify = S_At_Turn_2;
                servo_all_move(servo_motion[2]);
                xTaskResumeAll();
            }
            break;
        case S_At_Turn_2_angle:
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                vTaskSuspendAll();
                Task_select = S_At_Turn_2;
                Task_verify = S_At_Turn_2;
                servo_all_move(servo_motion[2]);
                xTaskResumeAll();
            }

            break;
        case S_At_Turn_2:                                                                    // 直线前进到达暂存区
            if (advance_angle_distance(angle_standard, imu_date, distance_now, Rough_TS_Back_2) == 1) //
            {
                vTaskSuspendAll();
                angle_standard = 89.2f;
                Task_select = Task_verify = S_To_Put_down_3;
                servo_all_move(servo_motion[1]);
                xTaskResumeAll();
            }
            break;
        case S_To_Put_down_2: // 在暂存区调整车身角度 
            if (direction_Set_biu(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                osDelay(100);
                vTaskSuspendAll();
                Task_select = S_To_Put_down_3;
                Task_verify = S_To_Put_down_3;
                color_location_sign = 0;
                color_date.date[2] = 0;
                Camera_date_status = 0;
                color_location_sign = 0;
                xTaskResumeAll();
                xQueueReceive(angle_Queue, &imu_date, portMAX_DELAY);
            }
            break;
        case S_To_Put_down_3: // 在暂存区调整车身角度 
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                osDelay(100);
                vTaskSuspendAll();
                servo_all_move(servo_motion[1]);
                Task_select = S_At_Put_down_2_0;
                Task_verify = S_At_Put_down_2_0;
                color_location_sign = 0;
                Arm_do_order = servo_sign = 0;
                color_sign = 3;
                Stack_circle_location();
                color_location_sign = 0;
                color_date.date[2] = 0;
                Camera_date_status = 0;
                xTaskResumeAll();

            }
            break;
        case S_At_Put_down_2_0: // 暂存区视觉定位
        {
            if (color_location_sign == 0)
            {
                Stack_circle_location();
                vTaskSuspendAll();
                back_sign = S_At_Put_down_2_0;
                if (Camera_date_status == 1 && color_date.date[2] == 33)
                {
                    color_circle_x = color_Stacking_x;
                    color_circle_y = color_Stacking_y;
                    Task_select = Color_cicle_location;
                    Task_verify = Color_cicle_location;
                    back_sign = S_At_Put_down_2_0;
                    Camera_date_status = 0;
                }
                else
                {
                    Stack_circle_location();
                }

                xTaskResumeAll();
            }
            else
            {
                vTaskSuspendAll();
                color_location_sign = 0;
                Arm_do_order = servo_sign = 0;
                color_sign=3;
                Task_select = Stacking;
                Task_verify = Stacking;

                xTaskResumeAll();
            }
            break;
        }
        case S_To_Put_down_4: // 在暂存区调整车身角度 
            if (direction_Set(angle_standard, imu_date) == 1)
            {
                speed_CTRL(0, 0, 0, 0);
                osDelay(100);
                vTaskSuspendAll();
                color_location_sign = 0;
                Arm_do_order = servo_sign = 0;
                color_sign=3;
                Task_select = Stacking;
                Task_verify = Stacking;
                xTaskResumeAll();

            }
            break;
        case Stacking: // 码垛
            switch (Arm_do_order)
            {
            case 0:
                switch (color[color_sign])
                {
                case 1: // 识别到的红色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, 100.5, 1000, 0, 0);
                    break;
                case 2: // 识别到的绿色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, -25.5, 1000, 0, 0);
                    break;
                case 3: // 识别到的蓝色物料放置
                    FSUS_SetServoAngle(servoUsart, 6, -145.5, 1000, 0, 0);
                    break;
                }
                osDelay(10);
                servo_all_move(servo_motion[12]);
                osDelay(servo_motion[12].time + 70);
                servo_all_move(servo_motion[13]);
                osDelay(servo_motion[13].time + 70);
                servo_all_move(servo_motion[14]);
                osDelay(servo_motion[14].time + 70);
                servo_all_move(servo_motion[15]);
                osDelay(servo_motion[15].time + 70);
                servo_all_move(servo_motion[39]);
                osDelay(servo_motion[39].time + 70);
                Arm_do_order++;
                break;
            case 1:
                switch (color[color_sign])
                {
                case red_circle: // 红色
                    Arm_do_order = 0;
                    color_sign++;
                    MaxArm_Motion = servo_motion[39];
                    MaxArm_Motion.value_goal[0] = servo_motion[27].value_goal[0];
                    MaxArm_Motion.time = 300;
                    servo_all_move(MaxArm_Motion);
                    osDelay(MaxArm_Motion.time + 70);

                    servo_all_move(servo_motion[27]);
                    osDelay(servo_motion[27].time + 70);
                    servo_all_move(servo_motion[28]);
                    osDelay(servo_motion[28].time + 70);
                    servo_all_move(servo_motion[29]);
                    osDelay(servo_motion[29].time + 70);

                    servo_all_move(servo_motion[40]);
                    osDelay(servo_motion[40].time + 70);
                    break;
                case green_circle: // 绿色
                    Arm_do_order = 0;
                    color_sign++;
                    servo_all_move(servo_motion[30]);
                    osDelay(servo_motion[30].time + 70);
                    servo_all_move(servo_motion[31]);
                    osDelay(servo_motion[31].time + 70);
                    servo_all_move(servo_motion[32]);
                    osDelay(servo_motion[32].time + 70);

                    servo_all_move(servo_motion[40]);
                    osDelay(servo_motion[40].time + 70);
                    break;
                case blue_circle: // 蓝色
                    Arm_do_order = 0;
                    color_sign++;
                    MaxArm_Motion = servo_motion[39];
                    MaxArm_Motion.value_goal[0] = servo_motion[33].value_goal[0];
                    MaxArm_Motion.time = 300;
                    servo_all_move(MaxArm_Motion);

                    osDelay(MaxArm_Motion.time + 70);
                    servo_all_move(servo_motion[33]);
                    osDelay(servo_motion[33].time + 70);
                    servo_all_move(servo_motion[34]);
                    osDelay(servo_motion[34].time + 70);
                    servo_all_move(servo_motion[35]);
                    osDelay(servo_motion[35].time + 70);

                    servo_all_move(servo_motion[40]);
                    osDelay(servo_motion[40].time + 70);
                    break;
                }
                if (color_sign >= 6)
                    Arm_do_order = 234;
                break;
            default:
                Task_select = Task_verify = Back_home_1;
                angle_standard=91.3f;
                break;
            }
            break;
        case Back_home_1:
            if (crosswise_angle_distance(angle_standard, imu_date, distance_now, TS_Start_left) == 1) //
            {
                vTaskSuspendAll();
                Uart5_LCD_show_string("Back_home");
                servo_all_move(servo_motion[0]);
                Task_select = Task_verify = Back_home_2;
                xTaskResumeAll();
            }
            break;
        case Back_home_2:
            if (advance_angle_distance(angle_standard, imu_date, distance_now, TS_Start_back) == 1) //
            {

                vTaskSuspendAll();
                Task_select = Task_verify = End;
                xTaskResumeAll();
            }
            break;

        case Color_cicle_location:  // 判断颜色圈位置
            if (Camera_date_status == 1)  // 如果相机数据状态为1
            {
                if (abs(color_date.date[0] - color_circle_x) > 12)  // 如果颜色数据的第一个元素与颜色圈的x坐标的差的绝对值大于2
                {
                    color_speed_dert = color_circle_x-color_date.date[0];  // 颜色速度差等于颜色数据的第一个元素减去颜色圈的x坐标
                    color_speed_dert = abs(color_speed_dert) > 5 ? color_speed_dert : color_speed_dert * 5;  // 如果颜色速度差的绝对值大于5，则颜色速度差不变，否则颜色速度差乘以5
                    color_speed_sum2 += color_speed_dert;  // 颜色速度和等于颜色速度和加上颜色速度差
                    color_speed_sum2 = color_speed_sum2 > 1000 ? 1000 : (color_speed_sum2 < -1000 ? -1000 : color_speed_sum2);  // 如果颜色速度和大于2000，则颜色速度和等于2000，否则如果颜色速度和小于-2000，则颜色速度和等于-2000，否则颜色速度和不变
                    color_speed_use = color_speed_dert * Direction_KP + color_speed_sum2 * Direction_KI;  // 使用的颜色速度等于颜色速度差乘以方向KP加上颜色速度和乘以方向KI
                    color_speed_use = color_speed_use > 100 ? 100 : (color_speed_use < -100 ? -100 : color_speed_use);  // 如果使用的颜色速度大于1000，则使用的颜色速度等于1000，否则如果使用的颜色速度小于-1000，则使用的颜色速度等于-1000，否则使用的颜色速度不变
                    crosswise_angle(angle_standard, imu_date, color_speed_use);  // 调用advance_angle函数，参数为imu_date的第三个元素，imu_date，使用的颜色速度
                }
                else if (abs(color_date.date[1] - color_circle_y) > 7)  // 否则，如果颜色数据的第二个元素与颜色圈的y坐标的差的绝对值大于2
                {
                    color_speed_sum2 = 0;  // 颜色速度和等于0
                    color_speed_dert = color_circle_y - color_date.date[1];  // 颜色速度差等于颜色圈的y坐标减去颜色数据的第二个元素
                    color_speed_dert = abs(color_speed_dert) > 5 ? color_speed_dert : color_speed_dert * 5;  // 如果颜色速度差的绝对值大于5，则颜色速度差不变，否则颜色速度差乘以5
                    color_speed_sum1 += color_speed_dert;  // 颜色速度和等于颜色速度和加上颜色速度差
                    color_speed_sum1 = color_speed_sum1 > 1000 ? 1000 : (color_speed_sum1 < -1000 ? -1000 : color_speed_sum1);  // 如果颜色速度和大于2000，则颜色速度和等于2000，否则如果颜色速度和小于-2000，则颜色速度和等于-2000，否则颜色速度和不变
                    color_speed_use = color_speed_dert * Direction_KP + color_speed_sum1 * Direction_KI;  // 使用的颜色速度等于颜色速度差乘以方向KP加上颜色速度和乘以方向KI
                    color_speed_use = color_speed_use > 100 ? 100 : (color_speed_use < -100 ? -100 : color_speed_use);  // 如果使用的颜色速度大于1000，则使用的颜色速度等于1000，否则如果使用的颜色速度小于-1000，则使用的颜色速度等于-1000，否则使用的颜色速度不变
                    advance_angle(angle_standard, imu_date, color_speed_use);  // 调用crosswise_angle函数，参数为imu_date的第三个元素，imu_date，使用的颜色速度
                }
                else  // 否则
                {
                    speed_CTRL(0, 0, 0, 0);  // 调用speed_CTRL函数，参数都为0
                    color_speed_sum1 = color_speed_sum2 = 0;  // 颜色速度和等于0
                    osDelay(300);  // 延迟200毫秒
                    if (target_location_sign < 6)  // 如果颜色圈位置标志小于6
                    {
                        target_location_sign++;  // 颜色圈位置标志加1
                    }
                    else  // 否则
                    {
                        target_location_sign = 0;  // 颜色圈位置标志等于0
                        Camera_die();  // 调用Camera_die函数
                        Task_select = back_sign;  // 任务选择等于返回标志
                        Task_verify = back_sign;  // 任务验证等于返回标志
                        color_location_sign = 1;  // 颜色位置标志等于1
                    }
                }
                Camera_date_status = 0;  // 相机数据状态等于0
            }
            else  // 否则
            {
//                speed_CTRL(0, 0, 0, 0);  // 调用speed_CTRL函数，参数都为0               
                if(back_sign==At_Put_down_2_0||back_sign==At_Put_down_1_1||back_sign==S_At_Put_down_1_1)
                {
                    Color_circle_location();
                }
                else
                {
                    Stack_circle_location();
                }
                osDelay(10);  // 延迟10毫秒
            }
            break;  // 跳出循环

        case End:
            start_status = 0;
            speed_CTRL(0, 0, 0, 0);
            break;
        
        }

        osDelay(10);
    }
    /* USER CODE END doing_Task */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
